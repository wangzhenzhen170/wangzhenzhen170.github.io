<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[css3动画]]></title>
    <url>%2F2018%2F09%2F21%2Fcss3%2F</url>
    <content type="text"><![CDATA[css动画的两大组成部分：transition和animation Transition在css3引入Transition（过渡）这个概念之前，css是没有时间轴的，也就是说，所有的状态变化都是即时完成 transition-duration: 1s; transition-delay: 1s; transition-property: height; transition-timing-function: ease; //简写 transition: 1s 1s height ease; transition的局限transition的优点在于简单易用，但又几个很大的局限性1.transition需要事件触发，所以没法在网页加载时自动发生2.transition时一次性的，不能重复发生，除非一再触发3.transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态4.一条transition规则只能定义一个属性的变化，不能涉及多个属性 Animation基本用法首先 css Animation需要指定动画一个周期持续的时间，以及动画效果的名称 div:hover { animation:1s rainbow; } 上面代码表示，当鼠标悬停在div元素上时，会产生名为rainbow的动画效果,持续时间为1s，为此，我们还需要用keyframes关键字，定义rainbow效果 @keyframes rainbow{ 0%{ background:#c00 } 50%{ background:red } 100%{ background:blue } } 默认情况下，动画只播放一次。加入infinite关键字，可以让动画无限次播放,也可以指定动画具体播放次数，比如3次 div:hover { animation:1s rainbow infinite; } 动画结束以后，会立即从结束状态跳回到起始状态。如果想让动画保持在结束状态，需要使用animation-fill-mode属性。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css3动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react]]></title>
    <url>%2F2018%2F09%2F20%2Freact%2F</url>
    <content type="text"></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex弹性布局]]></title>
    <url>%2F2018%2F09%2F18%2Fflex%2F</url>
    <content type="text"><![CDATA[Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。任何一个元素包括行内元素都可以指定为Flex布局，行内元素用display: inline-flex;Webkit内核的浏览器，必须加上-webkit前缀。1234.box&#123; display: -webkit-flex; /* Safari */ display: flex; &#125; 浏览器支持 Flexbox 的情况旧版浏览器，如IE 11或更低版本，不支持或仅部分支持 Flexbox 。如果你想安全的使用页面正常呈现，你应该退回到其他的 CSS 布局方式，比如结合float 的 display: inline-block 或者 display: table 等。但是，如果您只针对现代浏览器，那么 Flexbox 绝对值得一试。 基本概念采用Flex布局的元素，成为Flex容器，简称容器，它的所有子元素成为Flex项目（flex item)，简称项目容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis） 容器的属性容器的属性，即设为display: flex的元素 1.flex-direction 决定主轴的方向（即项目的排列方向）；flex-derection: row | row-reverse | colum |column-reverse;1234row (默认值)：主轴为水平方向，起点在左端row-reverse : 主轴为水平方向，起点在右端column : 主轴为垂直方向，起点在上上沿column-reverse : 主轴为垂直方向，起点在下沿]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[$.click(function(){}) 和 $.on('click',function(){})的区别]]></title>
    <url>%2F2016%2F09%2F26%2Fclick%2F</url>
    <content type="text"><![CDATA[click只能为页面现有的元素绑定点击事件，如果是动态生成的新的元素，是没有事件的而$(document).on(“click”,”指定的元素”,function(){});方法则是将指定的事件绑定在document上，而新产生的元素如果符合指定的元素，那就触发此事件总结：绑定事件的时候用on代替直接绑定：注意：1.jQuery版本要在1.7以上； 自 jQuery 版本 1.7 起，on() 方法是 bind()、live() 和 delegate() 方法的新的替代品； 如需移除事件处理程序，请使用 off() 方法；]]></content>
      <categories>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery attr方法获取input的checked属性问题]]></title>
    <url>%2F2016%2F09%2F20%2Finput%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[项目中我在用jQuery的attr这个方法获取input的checked属性值，但是总是undefined，经过查找资料用prop方法可以到达目的下面介绍这两种方法的区别1.通过prop方法获取checked属性，获取的checked返回值为boolean，选中为true,否则为flase1234567&lt;input type="checkbox" id="selectAll" onclick="checkAll()"&gt;全选 function checkAll() &#123; var checkedOfAll=$("#selectAll").prop("checked"); alert(checkedOfAll); $("input[name='procheck']").prop("checked", checkedOfAll); &#125; 2.如果使用attr方法获取时，如果当前input中初始化未定义checked属性，则不管当前是否选中，$(“#selectAll”).attr(“checked”)都会返回undefined1&lt;input type="checkbox" id="selectAll" onclick="checkAll()" &gt;全选 如果当前input中初始化已定义checked属性，则不管是否选中，$(“#selectAll”).attr(“checked”)都会返回checked.12345&lt;input type="checkbox" id="selectAll" onclick="checkAll()" checked&gt;全选 function checkAll() &#123; var checkedOfAll=$("#selectAll").attr("checked"); alert(checkedOfAll); 总结，如果使用jquery,应使用prop方法来获取和设置checked属性，不应使用attr.]]></content>
      <categories>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js Array数组方法总结（ES5与ES6）]]></title>
    <url>%2F2016%2F08%2F07%2Farray%2F</url>
    <content type="text"><![CDATA[数组的方法总结的不是太全，但是是我在项目中比较常用的方法 isArray()判断一个对象是不是数组12console.log(Array.isArray([]));//trueconsole.log(Array.isArray(&#123;&#125;));//false map() 方法对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组1234567var data = [1,2,3,4,5];var data1 = data.map(function(value，index，ary)&#123;return ++ value;&#125;);console.log(data); // [1, 2, 3, 4, 5]console.log(data1);// [2, 3, 4, 5, 6] forEach() 方法与map方法很相似，也是遍历数组的所有成员但是forEach方法一般不返回值，只用来操作数据，如果需要有返回值，一般使用map方法。注意：forEach方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用for循环。 filter() 返回结果为ture的成员组成的一个新数组，不会改变原数组1234[1, 2, 3, 4, 5].filter(function (elem) &#123; return (elem &gt; 3);&#125;)// [4, 5] find() 和filter相似 （ES6新增）但返回的不是数组，是结果为true的对象，不会改变原来数组1234[1, 2, 3, 4, 5].filter(function (elem) &#123; return (elem === 3);&#125;)//3 indexOf() lastIndexOf()indexOf 方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。lastIndexOf 方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。indexOf方法还可以接受第二个参数，表示搜索的开始位置。123var a = ['a', 'b', 'c'];a.indexOf('b') // 1a.indexOf('y') // -1 concat() 创建并返回一个新数组，例如：1234567var arr = [1,2,3];console.log(arr.concat(4,5)); // [1, 2, 3, 4, 5]console.log(arr); // [1, 2, 3]console.log(arr.concat([4,5])); // [1, 2, 3, 4, 5]console.log(arr.concat([4,5],[6,7])); // [1, 2, 3, 4, 5,6,7]console.log(arr.concat([4,[5,[6,7]]])); // [1, 2, 3, 4, [5, [6, 7]]]console.log(arr.concat(4,[5,[6,7]])); // [1, 2, 3, 4, 5,[6,7]] sort() 方法将数组中的元素排序并返回排序后的数组当不带参数时，默认按照顺序排序，也就是从小到大。当然，也可以直接给sort加一个比较函数比较。例如：1234567891011121314151617181920212223242526var arr = [1,4,7];arr.sort();console.log(arr); //[1,4,7]arr.sort(function(a,b)&#123;return a-b; //从小到大&#125;);console.log(arr); //[1,4,7]arr.sort(function(a,b)&#123;return b-a; //从大到小&#125;);console.log(arr); //[7,4,1]var num = new Array('one','three','Six','Five');num.sort(); //区分大小写排序console.log(num); // ["Five", "Six", "one", "three"]num.sort(function(s,t)&#123;var a = s.toLowerCase();var b = t.toLowerCase();if(a&lt;b) return -1;if(a&gt;b) return 1;return 0;&#125;);console.log(num); // ["Five", "one", "Six", "three"] toString() 返回数组得字符串形式例如：12var arr = [1,2,3];console.log(arr.toString());//"1,2,3" join() 方法将数组中所有元素都转化为字符串并连接在一起返回 最后生成的字符串。可以自己指定分隔的符号，如果不指定，默认使用逗号例如：123var arr = [1,2,3];console.log(arr.join());//"1,2,3"console.log(arr.join("-"));//"1-2-3" reverse() 方法将数组中的元素颠倒顺序，返回逆序的数组（返回的数组是其本身，原始数组已经改变了）例如123var arr = [1,2,3];arr.reverse();console.log(arr.join());//"3,2,1" 所以，如果想把一个字符串逆序的话，可以这样123var str = "abcdefg";console.log(str.split("").reverse().join(""));//"gfedcba" 返回的是新的值console.log(str); //"abcdefg" 当然了，原始的是不会变的 slice()方法返回指定数组的一个片段或子数组， 返回新的数组，不会修改原始数组Array.slice()方法返回指定数组的一个片段或子数组。它的两个参数分别指定了片段开始和结束的位置（a,b）。返回的是从a开始到b的不包括b的数组元素。如果只有一个参数(a).则代表从a到数组结尾的元素。如果参数中出现负数（-a). 则表示相对于数组中最后一个元素相距a的位置。比如（-3）代表倒数第三个元素到末尾。出现负数就先换算出来，然后按照范围规则找出来例如：1234567var arr = [1,2,3,4,5];console.log(arr.slice(0,3)); // [1, 2, 3]console.log(arr); // [1, 2, 3, 4, 5]console.log(arr.slice(3));//[4, 5]console.log(arr.slice(-3));// [3, 4, 5]console.log(arr.slice(-3,-1));// [3, 4]console.log(arr.slice(2,-1));// [3, 4] splice() 方法是在数组中插入或者删除元素的通用方法。它会修改原始数组的值，并返回一个新的数组序列splice()的第一个参数指定了插入或删除的起始位置，第二个参数指定了应该从数组中删除的元素的个数。第二个参数省略则默认删到末尾。12345var arr = [1,2,3,4,5,6,7,8];console.log(arr.splice(4)); //[5, 6, 7, 8]console.log(arr); // [1, 2, 3, 4]console.log(arr.splice(1,2));// [2, 3]console.log(arr); // [1, 4] splice()的前两个参数指定了需要删除的数组元素。紧随其后的任意个数的参数指定了需要插入到数组中的元素，并从第一个参数代表的位置开始插入。不同于上边的concat()，splice()是直接把数组插进去，比如下面的[1,2]12345var arr = [1,2,3,4,5];console.log(arr.splice(2,0,'a','b')); // []console.log(arr); // [1, 2, "a", "b", 3, 4, 5]console.log(arr.splice(2,1,[1,2],3));// ["a"]console.log(arr); // [1, 2, [1, 2], 3, "b", 3, 4, 5] push() 、pop()、 unshift() 、shift()把这些方法看成栈操作就行：前两者正常的栈操作，后两者是反向的栈操作push()和unshift()往数组中从后面、前面添加元素，并返回新数组的长度pop()和shift()删除数组中最后、最前的元素，并返回删除的元素例如：1234567891011121314var arr = [];console.log(arr.push(1,2,3));//3console.log(arr);//[1, 2, 3]console.log(arr.pop());// 3console.log(arr);//[1,2]console.log(arr.push([4,5]));//3console.log(arr);// [1, 2, [4, 5]]var arr = [];console.log(arr.unshift(1,2,3));//3console.log(arr);//[1, 2, 3]console.log(arr.shift());// 1console.log(arr);// [2, 3]console.log(arr.unshift([4,5]));//3console.log(arr);//[[4, 5], 2, 3] some(),every()这两个方法类似’断言’(assert),用来判断数组成员是否符合某种条件some方法只要由一个数组成员返回值是true，则整个some方法的返回值就是true，否则false12345 var arr = [1, 2, 3, 4, 5]; arr.some(function (elem, index, arr) &#123; return elem &gt;= 3; &#125;);// true every方法则是所有数组成员的返回值都是true，才返回true，否则false。12345 var arr = [1, 2, 3, 4, 5]; arr.every(function (elem, index, arr) &#123; return elem &gt;= 3; &#125;);// false ES6 数组方法扩展运算符 扩展运算符可以展开数组例如用Math.max方法求取数组最大元素，两种方法都等同与Math.max(1,2,3,4,5)123var arr = [1, 2, 3, 4, 5];Math.max.applay(null,ary)(ES5写法)；Math.max(...ary)(ES6写法)； 扩展应用符的应用1.复制数组（克隆数组，修改a2，a1不会改变）12345const a1 = [1, 2];// 写法一const a2 = [...a1];// 写法二const [...a2] = a1; 2.合并数组// ES5的合并数组arr1.concat(arr2, arr3);// ES6的合并数组[…arr1, …arr2, …arr3]3.与解构赋值结合123456789101112131415161718const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []const [first, ...rest] = ["foo"];first // "foo"rest // []// 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。const [...butLast, last] = [1, 2, 3, 4, 5];// 报错const [first, ...middle, last] = [1, 2, 3, 4, 5];// 报错 Array.form（） 将类数组转换成数组Set是ES6提供的新的数据结构，类似于数组，但值都是唯一的，不会由重复的值所以数组去重的方法12const ary = [1,1,5,2,2,3]；Array.form(new Set(ary)) includes() 表示某个数组是否包含给定的值，与字符串的includes方法类似该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。1234[1, 2, 3].includes(2) // true[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值123if (arr.indexOf(el) !== -1) &#123; // ... &#125; indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。 [NaN].indexOf(NaN) // -1 [NaN].includes(NaN // true]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ES6</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中字符串常用方法总结]]></title>
    <url>%2F2016%2F08%2F05%2Fsix%2F</url>
    <content type="text"><![CDATA[charAt()返回指定索引位置处的字符。如果超出有效范围的索引值返回空字符串。strObj.charAt(index)说明：index想得到的字符的基于零的索引。有效值是0与字符串长度减一之间的值。例如：var str = “ABC”; str.charAt(1); 结果：B slice()返回字符串的片段。strObj.slice(start,end)说明：start下标从0开始的strObj指定部分其实索引。如果start为负，将它作为length+start处理，此处length为字符串的长度。end小标从0开始的strObj指定部分结束索引。如果end为负，将它作为length+end处理，此处length为字符串的长度。例如：012345var str = “ABCDEF”; str.slice(2,4); 结果：CD substring()返回位于String对象中指定位置的子字符串。strObj.substring(start,end)说明：start指明子字符串的起始位置，该索引从0开始起算。end指明子字符串的结束位置，该索引从0开始起算。substring方法使用start和end两者中的较小值作为子字符串的起始点。如果start或end为NaN或者为负数，那么将其替换为0。例如：012345var str = “ABCDEF”;str.substring(2,4); // 或 str.substring(4,2);结果：CD substr()返回一个从指定位置开始的指定长度的子字符串。strObj.substr(start[,length])说明：start所需的子字符串的起始位置。字符串中的第一个字符的索引为0。length在返回的子字符串中应包括的字符个数。例如：var str = “ABCDEF”;str.substr(2,4);结果：CDEF indexOf()返回String对象内第一次出现子字符串位置。如果没有找到子字符串，则返回-1。strObj.indexOf(substr[,startIndex])说明：substr要在String对象中查找的子字符串。startIndex该整数值指出在String对象内开始查找的索引。如果省略，则从字符串的开始处查找。例如：var str = “ABCDECDF”;str.indexOf(“CD”，1); // 由1位置从左向右查找 123…结果：2 lastIndexOf()返回String对象中字符串最后出现的位置。如果没有匹配到子字符串，则返回-1。strObj.lastIndexOf(substr[,startindex])说明：substr要在String对象内查找的子字符串。startindex该整数值指出在String对象内进行查找的开始索引位置。如果省略，则查找从字符串的末尾开始。例如：01234567var str = “ABCDECDF”;str.lastIndexOf(“CD”,6); // 由6位置从右向左查找 …456结果：5 search()返回与正则表达式查找内容匹配的第一个字符串的位置。strObj.search(reExp)说明：reExp包含正则表达式模式和可用标志的正则表达式对象。例如：var str = “ABCDECDF”;str.search(“CD”); // 或 str.search(/CD/i);结果：2 concat()返回字符串值，该值包含了两个或多个提供的字符串的连接。str.concat([string1[,string2…]])说明：string1，string2要和所有其他指定的字符串进行连接的String对象或文字。例如：var str = “ABCDEF”;str.concat(“ABCDEF”,”ABC”);结果：ABCDEFABCDEFABC split()将一个字符串分割为子字符串，然后将结果作为字符串数组返回。strObj.split([separator[,limit]])说明：separator字符串或 正则表达式 对象，它标识了分隔字符串时使用的是一个还是多个字符。如果忽略该选项，返回包含整个字符串的单一元素数组。limit该值用来限制返回数组中的元素个数。例如：var str = “AA BB CC DD EE FF”;alert(str.split(“ “，3));结果：AA,BB,CC toLowerCase()返回一个字符串，该字符串中的字母被转换成小写。例如：var str = “ABCabc”;str.toLowerCase();结果：abcabc toUpperCase()返回一个字符串，该字符串中的所有字母都被转换为大写字母。例如：var str = “ABCabc”;str.toUpperCase();结果：ABCABC charCodeAt()返回一个整数，代表指定位置字符的Unicode编码。strObj.charCodeAt(index)说明：index将被处理字符的从零开始计数的编号。有效值为0到字符串长度减1的数字。如果指定位置没有字符，将返回NaN。例如：var str = “ABC”;str.charCodeAt(0);结果：65 fromCharCode()从一些Unicode字符串中返回一个字符串。String.fromCharCode([code1[,code2…]])说明：code1，code2…是要转换为字符串的Unicode字符串序列。如果没有参数，结果为空字符串。例如：String.fromCharCode(65,66,112);结果：ABp]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用JS获取地址栏参数的方法]]></title>
    <url>%2F2016%2F07%2F01%2Ffive%2F</url>
    <content type="text"><![CDATA[采用正则表达式获取地址栏参数 1234567891011function GetQueryString(name)&#123;var reg = new RegExp("(^|&amp;)"+ name +"=([^&amp;]*)(&amp;|$)");var r = window.location.search.substr(1).match(reg);if(r!=null)return unescape(r[2]); return null;&#125;// 调用方法alert(GetQueryString("参数名1"));alert(GetQueryString("参数名2"));alert(GetQueryString("参数名3")); 我们可以用javascript获得其中的各个部分例如对于这样一个URLhttp://www.maidq.com/index.html?ver=1.0&amp;id=6#imhere window.location.href整个URl字符串(在浏览器中就是完整的地址栏)本例返回值: http://www.maidq.com/index.html?ver=1.0&amp;id=6#imhere window.location.protocolURL 的协议部分本例返回值:http: window.location.hostURL 的主机部分本例返回值:www.maidq.com window.location.portURL 的端口部分如果采用默认的80端口(update:即使添加了:80)，那么返回值并不是默认的80而是空字符本例返回值:”” window.location.pathnameURL 的路径部分(就是文件地址)本例返回值:/fisker/post/0703/window.location.html window.location.search除了给动态语言赋值以外，我们同样可以给静态页面,并使用javascript来获得相信应的参数值本例返回值:?ver=1.0&amp;id=6 window.location.hash锚点本例返回值:#imhere]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入网址到打开网页发生了什么]]></title>
    <url>%2F2016%2F06%2F10%2Ffour%2F</url>
    <content type="text"><![CDATA[写在前面：这一部分讲一下我对HTTP协议的认识（这句话说的太大了，所以还是先大致写一遍，常学常新，后续不断更新吧）。说到HTTP协议，就要先澄清一下什么是HTTPS协议、TCP/IP协议、HTML，懂的人自然不困惑，但是新手确实不太分得清这些长得很像或常常一块儿出现的词。 HTTP协议(Hypertext Transfer Protocol)超文本传输协议，是一个面向事务的应用层协议。在服务器进程的80端口监听来自浏览器（不一定局限于浏览器）发送的请求，服务器要返回请求页面作为响应建立TCP连接，HTTP协议规定了请求和响应的交互遵守格式和规则。 HTTPS协议(Secure Hypertext Transfer Protocol)的全名叫安全超文本传输协议，其中的这个Secure就是和HTTP协议的区别，具体涉及到的是安全套接字层（SSL：Secure Sockets Layer，所以我们也常听到SSL证书），简言之HTTPS协议相对HTTP协议更加安全。 TCP/IP协议，从名字上看TCP协议是传输层协议，IP协议是网络层协议，而TCP/IP协议簇又包含了四层结构（网络接口层、网络层、传输层、应用层）区分于OSI七层模型，是互联网的基础。 HTML是超文本标记语言，它不是任何一个协议。HTML可理解为只是在浏览器上的一种语言，作用是显示一个页面。言归正传，HTTP协议在这过程中到底做了些什么呢？HTTP协议解决的是什么问题？一个打开页面的过程：用户上网输入网址–&gt;浏览器向DNS请求解析IP地址–&gt;域名系统DNS解析出服务器的IP地址–&gt;浏览器和服务器建立TCP连接–&gt;浏览器打包发送请求–&gt;服务器相应并返回文件–&gt;释放TCP连接–&gt;浏览器上显示页面可以看出，http协议和数据传输过程并没有太大关系，建立TCP连接（TCP协议才是传输层的协议）承担了这件事，http协议规定的是浏览器和服务器之间的报文。HTTP的报文结构HTTP报文包括三部分内容：1.对报文进行描述的起始行2.包含属性的首部块3.包含数据的主题部分（可选）HTTP又分为两类报文：请求报文：从客户端发送到服务器响应报文：从服务器发送到客户端这两类报文的区别就是开始行不同，请求报文的开始行叫请求行、响应报文的开始行叫状态行，其余部分是一样的。开始行结束会有“空格”加“回车”（CR+LF）和后面首部行分开，开始行内部三个字段（请求报文：方法、URL、版本，响应报文：版本、状态码、短语）是以空格隔开。首部行每一行结束都有“空格”加“回车”，首部行结束应该还有一个空行将首部行和后面实体部分隔开，即使后面没有实体部分（但是由于历史原因有些客户端和服务器在这种情况下错误的省略了最后的“空格”加“回车”，所以服务器和客户端也是能接收这样的报文的）实体部分是报文的可选部分，就是HTTP要传输的内容，所以很多请求报文没有实体部分，有些响应报文也没有实体部分。用打开csdn的主页举例子：上面没有提到报文实体部分，其实我们打开的是一个网页，实体部分就是一个html文件请求行中的方法上面的请求行中有个方法，这些方法是HTTP规范中定义的，用来告诉服务器做什么。HTTP请求报文的方法包括以下几种：常用的是GET、POST、HEAD这几种方法，其他还有诸如PUT、DELETE这些方法。事实上后面的这些方法并不是所有服务器上都能实现的，比如有些服务器对用户发布页面有限制，会禁止PUT方法。响应报文中的状态码状态码都是三位数字，以开头数字不同分为五个大类：1xx：信息状态码2xx：成功状态码（常见的是200）3xx：重定向状态码，如要完成请求还要进行下一步行动（常见304，缓存未失效）4xx：客户端错误状态码（常见404，无法请求URL）5xx：服务器错误状态码（常见502，服务器错误）具体每一大类里的个小类都有细微差别，可以参考RFC2616。仔细看报文内容还有cookie部分，Content-Encoding压缩方式，cache缓存等等内容，这些内容包含也很广泛，只能先挖坑以后再说。《HTTP权威指南》一书对这些内容有深入介绍。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中定义函数的方式]]></title>
    <url>%2F2016%2F06%2F07%2F%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[今天总结一下js中定义函数的几种方式第一种123function func1(参数)&#123;&lt;!--func1函数名--&gt; /*函数体*/ &#125; 这种方式是最常见的第二种 123var func2=function([参数])&#123;&lt;!--func2函数名--&gt;/*函数体*/&#125;; 这种方法是将一匿名函数赋给一个变量，调用方法：func2([函数]);这两种定义函数的方式应该是等价的，但是用法上是有区别的：123456//这样是正确的func(1);function func(a)&#123;alert(a);&#125; 123456789101112//这样是错误的，会提示func未定义，主要是在调用func之前没有定义func(1);var func = function(a)&#123;alert(a);&#125;//这样是正确的，在调用func之前有定义var func = function(a)&#123;alert(a);&#125;func(1); 第三种1var func3=new Function();]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css如何居中一个元素]]></title>
    <url>%2F2016%2F06%2F03%2Fcss%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[水平居中行级元素水平居中（父元素设置 text-align:center）123&lt;div style="width: 200px; height: 100px;border: 1px solid;text-align:center;"&gt; &lt;span&gt;行级元素垂直居中&lt;/span&gt;&lt;/div&gt; 块级元素固定宽度水平居中（margin: 0 auto）123&lt;div style="width: 200px; height: 100px;border: 1px solid;text-align: center;"&gt;&lt;div style="border: 1px solid red;margin: 0 auto;height: 50px;width: 80px;"&gt; 块级元素水平居中&lt;/div&gt;&lt;/div&gt; 块级元素不固定宽度水平居中（margin: 0 auto）html代码123&lt;div class="outer"&gt;&lt;div class="inner"&gt;&lt;/div&gt;&lt;/div&gt; 1.浮动元素css 代码12345678910111213.outer&#123;float: left;position: relative;left: 50%;border: 1px solid red;&#125;.inner&#123;border: 1px solid green;height: 100px;position: relative;float: left;right: 50%;&#125; 效果 2.display设为table margin: 0 auto;css 代码123456789.outer&#123;width: 100%&#125;.inner&#123;display: table;//重点border: 1px solid green;height: 100px;margin: 0 auto;//重点&#125; 效果 3.css3 fit-content margin: 0 auto;css 代码1234567891011.outer&#123;width: 100%&#125;.inner&#123;width: -moz-fit-content;width: -webkit-fit-content;width: fit-content;margin: 0 auto;border: 1px solid green;&#125; 效果 块级元素固定宽度，绝对定位水平居中123456789101112.outer&#123;width: 100%&#125;.inner&#123;width: 300px;position: absolute;/*绝对定位*/height:200px;margin: 0 auto;/*水平居中*/border: 1px solid green;left: 0;/*此处不能省略且为0*/right: 0;/*此处不能省略且为0*/&#125; 垂直居中父级高度确定的单行文本设置父级的height和line-height等高 vertical-align:middle 只有在表单元素th和td下生效 父级高度确定的多文本元素1.table-cell(ie6/7不支持)html代码123&lt;div class="box box1"&gt;&lt;span&gt;垂直居中&lt;/span&gt;&lt;/div&gt; css：12345.box1&#123;display: table-cell;vertical-align: middle;text-align: center;&#125; 2.display:flex12345.box1&#123;display: flex;justify-content:center;&lt;!--水平居中--&gt;align-items:Center;&lt;!--垂直居中--&gt;&#125; 3.display:-webkit-box1234567.box1&#123;display: -webkit-box;-webkit-box-pack:center;-webkit-box-align:center;-webkit-box-orient: vertical;text-align: center&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css布局 左侧宽度固定，右侧自适应]]></title>
    <url>%2F2016%2F05%2F20%2Fthird%2F</url>
    <content type="text"><![CDATA[最近学习了一种经典布局，固定左侧或右侧的宽度，另一侧自适应宽度，此种布局挺常用，尤其是像后台，大部分都是采用这种结构，还比如像订餐类的APP，进入商家的时候，会出现一堆饭的列表，左侧是饭的分类，右侧是饭的列表等等。反正挺实用，值得收藏！html代码：123456&lt;h1&gt;左侧固定 右侧自适应&lt;/h1&gt;&lt;div class="box"&gt;&lt;div id="left"&gt;固定&lt;/div&gt;&lt;div id="right"&gt;自适应&lt;/div&gt;&lt;/div&gt;&lt;footer&gt;后面的一个DIV，以确保前面的定位不会导致后面的变形&lt;/footer&gt; 他后面还有个#footer，用来测试在前面的定位搞定后会不会导致后面的div错位——如果错位了，那证明我们的定位方法必须改进。下面列举几个常见的方法： 一、固定宽度区使用绝对定位，自适应区照例设置margincss代码：1234567891011121314151617181920212223.box&#123;width: 100%;position: relative;&lt;!--相对定位--&gt;&#125;#left&#123;position: absolute;&lt;!--绝对定位--&gt;&lt;!--#left脱离文档流，相对于.box定位--&gt;width: 200px;height: 400px;background: red;top: 0;left: 0;&#125;#right&#123;height: 400px;background: green;margin-left: 200px;&lt;!--#right的默认宽度是100%(相对于父级)，那么他设置了margin后， 他的宽度就变成了100%-200，--&gt;&#125;#foot&#123;height: 50px;width: 100%;background: yellow;&#125; 效果如图：大家看到这种效果，那么我们算是成功了么？No！！！如果我们改变right的高度，使right的高度比left高度低如图：为什么会出现这种问题呢？原因是绝对定位使left部分脱离了文档流，让其他元素无视了它的存在，使后边的元素错乱，所以绝对定位的方式要么放弃掉要么将footer也绝对定位到底部。 二、通过浮动实现css代码：12345678910111213141516171819.box&#123;width: 100%;&#125;#left&#123;float: left;width: 200px;height: 400px;background: red;&#125;#right&#123;height: 200px;background: green;&#125;#foot&#123;height: 50px;width: 100%;background: yellow;clear: both;/*因为left浮动会脱离文档流，所以要清楚浮动*/&#125; 三、如果不考虑ie7及以下版本把.box设为display:table并指定宽度100%,然后把left和right设为display:table-cell;然后只给left指定一个宽度，那么right的宽度就变成自适应了。代码很少，而且不会有额外标签。不过这是IE7都无效的方法。css代码：1234567891011121314151617181920.box&#123; width: 100%; display: table; &#125; #left,#right&#123; display: table-cell; &#125; #left&#123; width: 200px; height: 100px; background: red; &#125; #right&#123; background: green; &#125; #foot&#123; height: 50px; width: 100%; background: yellow; &#125; 四、CSS3的新增属性 calc()如果不考虑浏览器的兼容问题的话，可以使用CSS3的新增属性 calc() ;calc是calculate的简写，汉语为计算的意思。css代码：123456789101112#left&#123;width: 200px;height: 200px;background: red;float: left;&#125;#right&#123;width: calc(100% - 200px);background: green;height: 200px;float: left;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github+hexo免费搭建博客]]></title>
    <url>%2F2016%2F05%2F18%2Fmy-second-blog%2F</url>
    <content type="text"><![CDATA[前言这是我第一篇博客，太开心了，第一篇就记录一下用gitHub+hexo搭建博客的详细步骤吧。使用github pages服务搭建博客的好处有：1.全是静态文件，访问速度快；2.免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；3.可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；4.数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；5.博客内容可以轻松打包、转移、发布到其它平台等等； 准备工作在开始一切之前，你必须已经： 有一个github账号，没有的话去注册一个； 安装了node.js、npm，并了解相关基础知识； 安装了git for windows（或者其它git客户端）本文所使用的环境： Windows8.1 node.js@5.5.0 git@1.9.2 hexo@3.2.2搭建github博客创建仓库新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了，是不是很方便？由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。几个注意的地方： 注册的邮箱一定要验证，否则不会成功； 仓库名字必须是：username.github.io，其中username是你的用户名； 仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效；创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。绑定域名当然，你不绑定域名肯定也是可以的，就用默认的 xxx.github.io 来访问，如果你想更个性一点，想拥有一个属于自己的域名，那也是OK的。首先你要注册一个域名，域名注册以前总是推荐去godaddy，现在觉得其实国内的阿里云也挺不错的，价格也不贵，毕竟是大公司，放心！绑定域名分2种情况：带www和不带www的。域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下你的用户名.github.io的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向你的用户名.github.io，这样可以保证无论是否添加www都可以访问，如下：然后到你的github项目根目录新建一个名为CNAME的文件（无后缀），里面填写你的域名，加不加www看你自己喜好，因为经测试： 如果你填写的是没有www的，比如 mygit.me，那么无论是访问 http://www.mygit.me 还是 http://mygit.me ，都会自动跳转到 http://mygit.me 如果你填写的是带www的，比如 www.mygit.me ，那么无论是访问 http://www.mygit.me 还是 http://mygit.me ，都会自动跳转到 http://www.mygit.me 如果你填写的是其它子域名，比如 abc.mygit.me，那么访问 http://abc.mygit.me 没问题，但是访问 http://mygit.me ，不会自动跳转到 http://abc.mygit.me 另外说一句，在你绑定了新域名之后，原来的你的用户名.github.io并没有失效，而是会自动跳转到你的新域名。配置SSH key为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。用git bash执行如下命令：1$ cd ~/. ssh #检查本机已存在的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。1ssh-keygen -t rsa -C "邮件地址" 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：将刚复制的内容粘贴到key那里，title随便填，保存。 测试是否成功1$ ssh -T git@github.com # 注意邮箱地址不用改 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access.看到这个信息说明SSH已配置成功！此时你还需要配置：12$ git config --global user.name "liuxianan"// 你的github用户名，非昵称$ git config --global user.email "xxx@qq.com"// 填写你的github注册邮箱 具体这个配置是干嘛的我没仔细深究。 使用hexo写博客hexo简介Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。官网： http://hexo.iogithub: https://github.com/hexojs/hexo 原理由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 注意事项安装之前先来说几个注意事项：很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行；hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导；hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的； 安装1$ npm install -g hexo 初始化在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是F:\Workspaces\hexo，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。 12$ cd /f/Workspaces/hexo/$ hexo init hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：12$ hexo g # 生成$ hexo s # 启动服务 执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的：hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章：http://blog.liuxianan.com/windows-port-bind.html 修改主题既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 官方主题。个人比较喜欢的2个主题：hexo-theme-jekyll 和 hexo-theme-yilia。首先下载这个主题：12$ cd /f/Workspaces/hexo/$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 下载后的主题都在这里：修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。 上传之前在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。 上传到github如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。首先，ssh key肯定要配置好。其次，配置_config.yml中有关deploy的部分：正确写法：1234deploy:type: gitrepository: git@github.com:liuxianan/liuxianan.github.io.gitbranch: master 错误写法：1234567deploy:type: githubrepository: https://github.com/liuxianan/liuxianan.github.io.gitbranch: master后面一种写法是hexo2.x的写法，现在已经不行了，无论是哪种写法，此时直接执行hexo d的话一般会报如下错误：``` bashDeployer not found: github 或者 Deployer not found: git 原因是还需要安装一个插件：1npm install hexo-deployer-git --save 其它命令不确定，部署这个命令一定要用git bash，否则会提示Permission denied (publickey).打开你的git bash，输入hexo d就会将本次有改动的代码全部提交，没有改动的不会： 常用hexo命令常见命令1234567hexo new "postName" #新建文章hexo new page "pageName" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写：1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令： 12hexo s -g #生成并本地预览hexo d -g #生成并上传 _config.yml这里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题. 写博客定位到我们的hexo根目录，执行命令：1hexo new 'my-first-blog' hexo会帮我们在_posts下生成相关md文件：我们只需要打开这个文件就可以开始写博客了，默认生成如下内容：当然你也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。一般完整格式如下：12345678---title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面---以下是正文 那么hexo new page ‘postName’命令和hexo new ‘postName’有什么区别呢？1hexo new page "my-second-blog" 生成如下：最终部署时生成：hexo\public\my-second-blog\index.html，但是它不会作为文章出现在博文目录。 如何让博文列表不显示全部内容默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？答案是在合适的位置加上即可，例如：12345678910# 前言使用github pages服务搭建博客的好处有：1. 全是静态文件，访问速度快；2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；&lt;!--more--&gt;4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；5. 博客内容可以轻松打包、转移、发布到其它平台；6. 等等； 最终效果：]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
